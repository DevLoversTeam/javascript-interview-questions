# JavaScript

## Найпопулярніші запитання та відповіді на співбесіді з JavaScript

<details>
<summary>1. Що таке JavaScript?</summary>

- JavaScript — це динамічна, прототипно-орієнтована мова програмування, яка використовується для створення інтерактивного контенту на вебсторінках. Вона підтримує подієве програмування, асинхронність і працює в браузері, а також на сервері через Node.js.
</details>

<details>
<summary>2. Які ключові слова використовуються для оголошення змінних у JavaScript?</summary>

- У JavaScript змінні можна оголошувати за допомогою трьох ключових слів:

1. `var`

- Старий спосіб оголошення змінних.
- Область видимості: функціональна (в межах функції, а не блоку).
- Підтримує підняття (hoisting): змінну можна використовувати до оголошення, але значення буде undefined.
- Не рекомендується через можливість помилок.

  ```javascript
  var x = 10;
  ```

1. `let`

- Використовується для змінних, які можуть змінювати значення.
- Область видимості: блочна (в межах {}).
- Не дозволяє повторного оголошення в межах однієї області.
- Не піддається підняттю з доступом до значення.

  ```javascript
  let y = 20;
  y = 30; // Можна змінити значення
  ```

1. `const`

- Використовується для змінних, значення яких не змінюється.
- Область видимості: блочна.
- Потрібно обов’язково ініціалізувати при оголошенні.
- Якщо змінна є об’єктом або масивом, значення властивостей можна змінювати, але саму змінну перевизначити не можна.

  ```javascript
  const z = 40;
  // z = 50; // Помилка
  ```

- **Рекомендації:**
  - Використовувати `const` для змінних, які не змінюються.
  - Використовувати `let` для змінних, які змінюють значення.
  - `var` уникати, якщо це не потрібно для специфічної підтримки старих браузерів.

</details>

<details>
<summary>3. Перерахуйте типи даних у JavaScript.</summary>

1. **Примітивні:**

- `string`
- `number`
- `boolean`
- `null`
- `undefined`
- `bigint`
- `symbol`

2. **Складні:**

- `object` (включаючи масиви, функції, дати тощо).
</details>

<details>
<summary>4. У чому різниця між функціональним (functional) і подієвим (event-driven) програмуванням у JavaScript?</summary>

- **Функціональне програмування:**

  - Базується на чистих функціях, які не мають побічних ефектів.
  - Дані не змінюються, використовується іммутабельність.
  - Код пишеться у вигляді композиції функцій (`map`, `reduce`, `filter`).
  - Наприклад: обробка даних у масиві через функції вищого порядку.

- **Подієве програмування:**

  - Реакція на події (`click`, `hover`, `async responses`).
  - Використовує слухачі (`event listeners`) та обробники подій (`callbacks`).
  - Побудоване на взаємодії з подіями в середовищі (браузері чи Node.js).
  - Наприклад: виклик функції при кліку на кнопку.

</details>

<details>
<summary>5. У якому році відбувся перший реліз JavaScript, і в якому браузері він був вперше використаний?</summary>

- Перший реліз JavaScript відбувся в 1995 році. Він був вперше реалізований у браузері Netscape Navigator.
</details>

<details>
<summary>6. Чим відрізняється масив та обʼєкт? У яких випадках що використовуєте?</summary>

- **Масив:**

  - Використовується для зберігання впорядкованих елементів.
  - Індексовані значення (0, 1, 2, …).
  - Підходить для роботи з колекціями даних, де порядок важливий або коли потрібно виконувати операції типу сортування.

- **Обʼєкт:**

  - Використовується для зберігання пар "ключ-значення".
  - Доступ до значень через ключі (не індекси).
  - Підходить для зберігання даних з різними властивостями або для створення складних структур.

- **Використання:**

1. **Масив:** коли порядок елементів важливий або ви працюєте з колекцією однотипних елементів (наприклад, список користувачів).
2. **Обʼєкт:** коли потрібно зберігати дані з різними властивостями або асоціативні пари (наприклад, профіль користувача з різними атрибутами).

</details>

<details>
<summary>7. Events в JavaScript. Розкажіть про event propagation, bubbling, delegation, preventing тощо.</summary>

- **Event Propagation** — це процес, при якому подія, що сталася на елементі, "поширюється" через DOM дерево. Є два основні етапи:

1. **Bubbling** (Спливання):
   Подія спочатку викликається на найбільш вкладеному елементі, потім вона спливає до батьківських елементів (від внутрішнього до зовнішнього). Наприклад, якщо клікнути на кнопку всередині контейнера, подія спочатку буде оброблятися кнопкою, потім контейнером, і так далі, поки не досягне кореневого елемента (document).

2. **Capturing** (Ловлення):
   Подія спочатку обробляється на найвищому рівні DOM дерева (наприклад, document), а потім спускається вниз до цільового елемента.

- **Event Delegation** — це техніка обробки подій, коли ви додаєте один обробник подій на батьківський елемент, а не на кожен окремий дочірній елемент. Це дозволяє зменшити кількість обробників і є ефективним способом обробки подій на динамічно створених елементах.

- **Preventing Default Behavior** (Запобігання стандартній поведінці):

  - Метод event.preventDefault() дозволяє зупинити стандартну поведінку події. Наприклад, можна скасувати перезавантаження сторінки при натисканні на посилання або скасувати відправку форми.

- **stopPropagation() vs. stopImmediatePropagation():**

  - stopPropagation(): Зупиняє подальше поширення події по DOM, але не скасовує інші обробники подій на поточному елементі.
  - stopImmediatePropagation(): Зупиняє подальше поширення події і скасовує інші обробники подій, що могли бути зареєстровані на тому самому елементі.

</details>

<details>
<summary>8. Чи можливо перевизначити const?</summary>

- Ні, значення, оголошене через const, не можна змінити. Це означає, що ви не можете переназначити змінну, оголошену з const, на нове значення. Однак, якщо const використовується для оголошення обʼєкта або масиву, ви все ще можете змінювати його вміст (наприклад, додавати властивості до обʼєкта або елементи до масиву). Тобто, const гарантує, що сама змінна не може бути переназначена, але не захищає від змін всередині складних типів даних (масивів, обʼєктів).
</details>

<details>
<summary>9. Чи відомі вам принципи DRY, KISS, YAGNI, SOLID?</summary>

- Так, ці принципи широко використовуються в програмуванні для забезпечення чистого, підтримуваного і ефективного коду.

1. **DRY (Don't Repeat Yourself)** — уникайте дублювання коду. Якщо одна й та сама логіка зустрічається в кількох місцях, варто створити спільну функцію або метод, щоб зробити код більш зручним для підтримки.

2. **KISS (Keep It Simple, Stupid)** — підтримуйте код простим і зрозумілим. Уникайте надмірної складності і зайвих абстракцій. Простота покращує підтримуваність і знижує ймовірність помилок.

3. **YAGNI (You Aren't Gonna Need It)** — не додавайте функціональність, яку наразі не потрібно. Створювати код тільки для майбутніх можливостей може призвести до зайвих витрат часу і складності.

4. **SOLID** — набір принципів для об'єктно-орієнтованого програмування, що допомагають створювати гнучкий, зрозумілий і підтримуваний код:

- S (Single Responsibility Principle) — кожен клас чи функція має виконувати одну задачу.
- O (Open/Closed Principle) — код має бути відкритим для розширення, але закритим для модифікації.
- L (Liskov Substitution Principle) — обʼєкти підкласів повинні заміняти обʼєкти батьківських класів без порушення роботи програми.
- I (Interface Segregation Principle) — не змушуйте класи реалізовувати інтерфейси, які вони не використовують.
- D (Dependency Inversion Principle) — залежності повинні бути від абстракцій, а не від конкретних класів.

</details>

<details>
<summary>10. У чому відмінності LocalStorage від SessionStorage?</summary>

- **LocalStorage:**

  - Зберігає дані без обмежень по часу, дані зберігаються навіть після закриття браузера або вкладки.
  - Доступні для всіх вкладок і вікон того ж самого домену.
  - Обмеження на обсяг — зазвичай 5-10 МБ на домен.
  - Дані зберігаються, поки вони не будуть явно видалені.

- **SessionStorage:**

  - Дані зберігаються тільки в межах однієї сесії (до закриття вкладки або вікна браузера).
  - Доступні тільки в тій самій вкладці або вікні, в якій були збережені.
  - Обсяг схожий на LocalStorage (5-10 МБ).
  - Дані видаляються автоматично при закритті вкладки або браузера.

- **Основні відмінності:**

  - **Тривалість зберігання:** LocalStorage — дані зберігаються постійно, SessionStorage — тільки на час сесії.
  - **Доступність:** LocalStorage доступний для всіх вкладок, SessionStorage — тільки для поточної вкладки.

</details>

<details>
<summary>11. Що таке замикання (closure) в JavaScript і як воно працює?</summary>

- **Замикання (closure)** — це функція, яка "запам'ятовує" оточення, в якому була створена. Це дозволяє функції доступ до змінних, навіть після того, як зовнішня функція, в якій вона була оголошена, завершила своє виконання.

- **Як це працює:**

  - **Оточення:** Кожна функція в JavaScript має доступ до змінних, які знаходяться в її власному оточенні (локальні змінні), а також до змінних, які були доступні в оточенні, де функція була створена.
  - **Замикання:** Коли функція всередині іншої функції повертається або передається, вона все ще має доступ до змінних оточення, навіть якщо зовнішня функція вже завершила виконання.

- **Приклад:**

  ```javascript
  function outer() {
    let counter = 0; // локальна змінна зовнішньої функції

    return function inner() {
      // внутрішня функція
      counter++; // доступ до змінної outer()
      console.log(counter);
    };
  }

  const increment = outer(); // викликаємо outer, що повертає функцію inner
  increment(); // виведе 1
  increment(); // виведе 2
  ```

</details>

<details>
<summary>12. Що таке Кукі (cookies) і як вони працюють в JavaScript?</summary>

- Кукі (cookies) — це невеликі фрагменти даних, які вебсайт зберігає в браузері користувача. Вони використовуються для зберігання інформації, яка може бути використана для ідентифікації користувача, збереження налаштувань, відслідковування сесій тощо.

- **Як працюють кукі в JavaScript:**

1.  **Зчитування кукі:** Веб-браузер автоматично додає всі кукі для поточного домену до заголовка запиту, і JavaScript може отримати їх через document.cookie.

    ```javascript
    const cookies = document.cookie;
    console.log(cookies); // виведе всі кукі у вигляді рядка
    ```

2.  **Запис кукі:** Кукі встановлюються за допомогою властивості document.cookie. Формат для встановлення кукі виглядає так:

    ```javascript
    document.cookie =
      "name=value; expires=Thu, 31 Dec 2025 23:59:59 UTC; path=/";
    ```

    - У цьому прикладі:

      - "name=value" — це ключ-значення кукі.
      - expires — вказує дату, коли кукі стане неактивним. Якщо не вказано, кукі буде тимчасовим і видалиться після закриття браузера.
      - path — визначає, до якого шляху на сайті доступна кукі.

3.  **Видалення кукі:** Щоб видалити кукі, потрібно встановити її термін придатності в минуле:

    ```javascript
    document.cookie = "name=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/";
    ```

- **Особливості:**

  - Термін дії: Кукі можуть бути тимчасовими або мати встановлений термін дії.
  - Обмеження на розмір: Кожна кукі може зберігати до 4 КБ даних, і браузер зберігає до 20 кукі на домен.
  - Обмеження на доступність: Кукі можуть бути доступні лише на тому домені і підкаталозі, де вони були встановлені.
  - Безпека: Кукі можуть бути позначені як Secure (щоб передавались лише через HTTPS) і HttpOnly (щоб вони не були доступні через JavaScript).

- **Використання кукі:**
  - Ідентифікація користувача (наприклад, для збереження сесій).
  - Збереження налаштувань користувача (темна/світла тема, мова сайту).
  - Відслідковування статистики (аналітика).
  - Кукі є важливим інструментом для взаємодії між клієнтом і сервером, але їх потрібно використовувати обережно через питання конфіденційності та безпеки.

</details>

<details>
<summary>13. Що таке область видимості змінної?</summary>

- **Область видимості змінної** — це частина коду, в межах якої до змінної можна отримати доступ. У JavaScript існують три основні типи області видимості:

1. **Глобальна область видимості (Global Scope):**

- Змінна доступна у всьому коді.
- Змінні, оголошені поза будь-якими функціями або блоками, автоматично стають глобальними.
- Глобальні змінні створюються з використанням ключових слів var, let, const, або без них (хоча останнє — погана практика).

  ```javascript
  var globalVar = "I am global"; // доступна у всьому коді

  function test() {
    console.log(globalVar); // доступ до глобальної змінної
  }
  test();
  ```

2. **Функціональна область видимості (Function Scope):**

- Змінні, оголошені всередині функції з використанням var, доступні лише в межах цієї функції.
- Ця область видимості застосовується лише до var. Змінні let і const підкоряються блочній області видимості.

  ```javascript
  function test() {
    var localVar = "I am local";
    console.log(localVar); // доступна всередині функції
  }
  test();
  console.log(localVar); // помилка: localVar не визначена
  ```

3. **Блочна область видимості (Block Scope):**

- Змінні, оголошені з використанням let або const, доступні тільки всередині блоку {}.
- Не застосовується до змінних, оголошених через var.

  ```javascript
  {
    let blockVar = "I am block scoped";
    const blockConst = "I am also block scoped";
    console.log(blockVar); // доступна
  }
  console.log(blockVar); // помилка: blockVar не визначена
  ```

- **Вкладені області видимості:**

  - Внутрішня область може отримати доступ до змінних з зовнішньої області, але не навпаки.

  ```javascript
  function outer() {
    let outerVar = "outer";
    function inner() {
      console.log(outerVar); // доступ до змінної зовнішньої функції
    }
    inner();
  }
  outer();
  ```

- **Hoisting (Підняття):**

  - У JavaScript змінні, оголошені через var, "піднімаються" на початок своєї області видимості, але без ініціалізації.

  - Змінні, оголошені через let і const, також піднімаються, але недоступні до моменту їхньої ініціалізації (це називається "Temporal Dead Zone").

  ```javascript
  console.log(a); // undefined
  var a = 10;

  console.log(b); // помилка
  let b = 20;
  ```

</details>

<details>
<summary>14. Що таке анонімна функція?</summary>

- Анонімна функція — це функція, яка не має імені. Вона часто використовується там, де функцію потрібно створити швидко і немає необхідності використовувати її повторно.

- **Приклади анонімних функцій у JavaScript:**

1. **Функція як аргумент:** Анонімні функції часто передаються як аргументи до інших функцій (наприклад, у методах `map`, `filter`, `forEach`).

   ```javascript
   const numbers = [1, 2, 3];
   const doubled = numbers.map(function (num) {
     return num * 2;
   });
   console.log(doubled); // [2, 4, 6]
   ```

2. **Функціональний вираз:** Анонімна функція може бути присвоєна змінній.

   ```javascript
   const greet = function () {
     console.log("Hello");
   };
   greet(); // Hello
   ```

3. **Самовиконувана функція (IIFE):** Анонімна функція може бути негайно виконана.

   ```javascript
   (function () {
     console.log("I am an IIFE");
   })();
   ```

4. **У стрілкових функціях:** Стрілкові функції — це синтаксично скорочений варіант анонімних функцій.

   ```javascript
   const add = (a, b) => a + b;
   console.log(add(2, 3)); // 5
   ```

- **Переваги анонімних функцій:**

  - **_Короткий синтаксис:_** Особливо у випадку однорядкових функцій.
  - **_Локальність:_** Використовуються лише там, де потрібні, що сприяє чистоті коду.

- **Недоліки:**
  - **_Немає імені:_** Ускладнюється налагодження коду, оскільки у стеку викликів такі функції позначаються як `<anonymous>`.
  - **_Відсутність повторного використання:_** Не можна викликати повторно без збереження в змінну або передачі куди-небудь.
  </details>

<details>
<summary>15. Що таке стрілкова функція і як вона відрізняється від звичайної функції?</summary>

- Стрілкова функція (arrow function) — це скорочений синтаксис для оголошення функцій у JavaScript, введений в ES6. Вона має компактну форму і поводиться інакше, ніж звичайна функція, особливо щодо контексту `this`.

- **Синтаксис:**

  ```javascript
  const functionName = (param1, param2) => {
    // тіло функції
    return param1 + param2;
  };
  ```

- **Приклад однорядкової функції:**

  ```javascript
  const add = (a, b) => a + b; // автоматично повертає результат
  console.log(add(2, 3)); // 5
  ```

- **Основні відмінності:**

1.  **Контекст** `this`:

    - У стрілкових функцій немає власного `this`. Вони успадковують `this` із зовнішнього оточення.
    - У звичайних функцій `this` залежить від способу виклику (динамічно прив'язується).

    ```javascript
    const obj = {
      value: 10,
      regularFunction: function () {
        console.log(this.value); // 10
      },
      arrowFunction: () => {
        console.log(this.value); // undefined (успадковує this із глобального контексту)
      },
    };

    obj.regularFunction();
    obj.arrowFunction();
    ```

2.  **Конструктор:**

    - Стрілкові функції не можуть використовуватися як конструктори.
    - Виклик new зі стрілковою функцією викликає помилку.

    ```javascript
    const Arrow = () => {};
    const Regular = function () {};

    new Arrow(); // Помилка
    new Regular(); // Працює
    ```

3.  **Синтаксис:**

    - Стрілкова функція більш лаконічна, особливо для однорядкових операцій.
    - Звичайна функція може мати більш розгорнутий вигляд, але є універсальною.

    ```javascript
    // Звичайна функція
    function multiply(a, b) {
      return a * b;
    }

    // Стрілкова функція
    const multiplyArrow = (a, b) => a * b;
    ```

4.  `arguments`:

    - У стрілкових функцій немає псевдомасиву `arguments`. Щоб отримати аргументи, слід використовувати оператор rest (...).
    - У звичайних функцій є доступ до `arguments`.

    ```javascript
    const regularFunc = function () {
      console.log(arguments); // Псевдомасив
    };

    const arrowFunc = (...args) => {
      console.log(args); // Справжній масив
    };

    regularFunc(1, 2, 3);
    arrowFunc(1, 2, 3);
    ```

5.  **Ключове слово** `super`:

    - Стрілкові функції успадковують `super` із зовнішнього контексту.
    - У звичайних функцій `super` визначається залежно від їх виклику.

- **Коли використовувати:**

  - Стрілкові функції добре підходять для коротких виразів, обробників подій, методів масивів (`map`, `filter`, `reduce`), а також там, де важливе збереження контексту `this`.
  - Звичайні функції варто використовувати для більш складних сценаріїв, що потребують власного `this`, `arguments` або можливості виклику через `new`.

</details>
